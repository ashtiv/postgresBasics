## 3. What is PostgreSQL All About?

PostgreSQL is a powerful and open-source  relational database  management system (RDBMS) that is known for its reliability, scalability, and extensibility. It was first released in 1989 and has since become one of the most popular  RDBMSs  in the world.

PostgreSQL supports a wide range of  programming languages, including C, C++, Java, Python, and Ruby, and provides built-in support for many features that are typically available only through add-ons in other databases, such as  JSON  and  XML  data types, full-text search, and advanced indexing.

PostgreSQL is also highly customizable, with a large number of extensions and plug-ins available to add functionality and improve performance.

## 4. Database Design

Database design is the process of creating a  database schema  that defines the structure and organization of the data stored in a database. A good  database design  can improve performance, reduce redundancy, and make it easier to maintain and update the database in the future.

There are several key concepts and terms that are important to understand when designing a database:

-   Entity: A thing or concept that we want to store data about, such as a person, product, or order.
-   Attribute: A characteristic of an entity, such as the name, age, or price of a product.
-   Primary key: A unique identifier for each entity that is used to distinguish it from other entities in the same table.
-   Foreign key: A reference to a primary key in another table that is used to establish relationships between entities.
-   Relationship: A connection between two entities that is defined by a  foreign key.

## Quiz 1: Database Terminology

Quiz questions to test your knowledge of  database terminology.

## 5. Creating Tables

In PostgreSQL, tables are created using the  `CREATE TABLE`  statement. The basic syntax for creating a table is as follows:

```
CREATE TABLE table_name (
  column1 datatype1 [constraints],
  column2 datatype2 [constraints],
  ...
);

```

Here is an example of creating a simple  `users`  table with two columns:

```
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50) NOT NULL
);

```

In this example, we are creating a table called  `users`  with two columns:  `id`  and  `name`. The  `id`  column uses the  `SERIAL`  data type, which automatically generates a unique value for each new row. The  `PRIMARY KEY`  constraint indicates that the  `id`  column is the primary key for the table. The  `name`  column uses the  `VARCHAR`  data type with a length of 50 characters and the  `NOT NULL`  constraint, which means that a value must be provided for this column when inserting a new row.

## 6. Analyzing CREATE TABLE

In PostgreSQL, we can use the  `\d`  command to display information about a table, including its columns and constraints. For example, to display information about the  `users`  table we created in the previous step, we can run the following command:

sql

Copy

```
\d users

```

This will display the following output:

```
                                        Table "public.users"
 Column |         Type          | Collation | Nullable |               Default                
--------+-----------------------+-----------+----------+--------------------------------------
 id     | integer               |           | not null | nextval('users_id_seq'::regclass)
 name   | character varying(50) |           | not null | 
Indexes:
    "users_pkey" PRIMARY KEY, btree (id)

```

This output shows that the  `users`  table has two columns (`id`  and  `name`), with the  `id`  column being the primary key. It also shows that the  `id`  column uses the  `integer`  data type and the  `name`  column uses the  `character varying`  data type with a length of 50 characters.

## 7. Inserting Data Into a Table

In PostgreSQL, data is inserted into a table using the  `INSERT INTO`  statement. The basic syntax for inserting data is as follows:

```
INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);

```

Here is an example of inserting a new row into the  `users`  table we created earlier:

```
INSERT INTO users (name) VALUES ('Alice');

```

This will insert a new row into the  `users`  table with a value of  `'Alice'`  for the  `name`  column. Since we did not provide a value for the  `id`  column, it will be automatically generated by the  `SERIAL`  data type.

## 8. Retrieving Data with SELECT

In PostgreSQL, data is retrieved from a table using the  `SELECT`  statement. The basic syntax for selecting data is as follows:

```
SELECT column1, column2, ... FROM table_name WHERE condition;

```

Here is an example of selecting all rows from the  `users`  table:

```
SELECT* FROM users;

```

This will retrieve all columns (`*`) from the  `users`  table.

## Coding Exercise 1: Create, Insert, and Select!

Let's practice creating a table, inserting data into it, and retrieving data from it.

1.  Create a new table called  `employees`  with the following columns:

-   `id`  (serial, primary key)
-   `name`  (varchar(50), not null)
-   `age`  (integer, not null)
-   `salary`  (numeric(10,2), not null)

2.  Insert the following data into the  `employees`  table:

-   Name:  Alice, Age: 25, Salary: 50000.00
-   Name:  Bob, Age: 30, Salary: 60000.00
-   Name: Charlie, Age: 35, Salary: 70000.00

3.  Retrieve all columns from the  `employees`  table.

## 9. Calculated Columns

In PostgreSQL, we can create calculated columns by using expressions in the  `SELECT`  statement. These expressions can perform calculations on existing columns or combine multiple columns into a new column.

Here is an example of creating a  calculated column  that calculates the total revenue for each order in an  `orders`  table:

```
SELECT order_id, quantity * price AS total_revenue FROM orders;

```

In this example, we are multiplying the  `quantity`  and  `price`  columns for each row and assigning the result to a new column called  `total_revenue`.

## 10. Calculating Phone Revenue

Let's practice creating a calculated column using a real-world example.

Suppose we have a  `sales`  table that contains information about phone sales, including the number of phones sold and the price per phone. We want to calculate the total revenue for each sale and display it in a new column called  `total`.

Here is an example of how we can do this:

```
SELECT sale_id, phone_price * phone_quantity AS total FROM sales;

```

In this example, we are multiplying the  `phone_price`  and  `phone_quantity`  columns for each row and assigning the result to a new column called  `total`.

## Coding Exercise 2: Using  Calculated Columns

Let's practice creating a calculated column.

Suppose we have a  `products`  table that contains information about products, including the price per unit and the number of units sold. We want to calculate the total revenue for each product and display it in a new column called  `revenue`.

1.  Create a new table called  `products`  with the following columns:

-   `id`  (serial, primary key)
-   `name`  (varchar(50), not null)
-   `price_per_unit`  (numeric(10,2), not null)
-   `units_sold`  (integer, not null)

2.  Insert the following data into the  `products`  table:

-   Name: Product A, Price per unit: 10.00, Units sold: 100
-   Name: Product B, Price per unit: 20.00, Units sold: 200
-   Name: Product C, Price per unit: 30.00, Units sold: 300

3.  Create a calculated column called  `revenue`  that calculates the total revenue for each product.
    
4.  Retrieve all columns from the  `products`  table.
    

## 11. Exercise Solution

Here is a possible solution to  Coding Exercise  2:

```
-- Step 1: Create a new table
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  price_per_unit NUMERIC(10,2) NOT NULL,
  units_sold INTEGER NOT NULL
);

-- Step 2: Insert data into the table
INSERT INTO products (name, price_per_unit, units_sold) VALUES
('Product A', 10.00, 100),
('Product B', 20.00, 200),
('Product C', 30.00, 300);

-- Step 3: Create a calculated column
SELECT id, name, price_per_unit, units_sold, price_per_unit * units_sold AS revenue FROM products;

-- Step 4: Retrieve all columns from the table
SELECT * FROM products;

```

This solution creates a  `products`  table with four columns (`id`,  `name`,  `price_per_unit`, and  `units_sold`), inserts three rows of data into the table, creates a calculated column called  `revenue`  that multiplies the  `price_per_unit`  and  `units_sold`  columns for each row, and retrieves all columns from the table.

## 12. String Operators and Functions

In PostgreSQL, we can use  string operators  and functions to manipulate strings and perform operations on them. Some common string operators and functions include:

-   `||`:  Concatenation  operator that combines two strings into one.
-   `LENGTH(string)`: Function that returns the length of a string.
-   `SUBSTR(string, start, length)`: Function

## 13. Filtering Rows with "Where"

In  PostgreSQL, we can use the  `WHERE`  keyword to filter rows based on a specified condition. The basic syntax for using  `WHERE`  is as follows:

```
SELECT column1, column2, ... FROM table_name WHERE condition;

```

Here is an example of using  `WHERE`  to filter rows from an  `employees`  table based on age:

```
SELECT * FROM employees WHERE age > 30;

```

This will retrieve all columns (`*`) from the  `employees`  table where the  `age`  column is greater than 30.

## 14. More on the "Where" Keyword

In addition to using  comparison operators  like  `>`  and  `<`, we can also use other operators in conjunction with  `WHERE`  to filter rows based on more complex conditions. Some common operators include:

-   `=`: Equal to
-   `<>`  or  `!=`: Not equal to
-   `LIKE`: Matches a pattern (use  `%`  as a wildcard)
-   `IN`: Matches any of a list of values
-   `NOT`: Negates a condition

Here are some examples of using these operators in  `WHERE`  clauses:

sql

Copy

```
SELECT * FROM employees WHERE name = 'Alice'; -- Matches rows where name is exactly 'Alice'
SELECT * FROM employees WHERE age <> 30; -- Matches rows where age is not equal to 30
SELECT * FROM employees WHERE name LIKE 'A%'; -- Matches rows where name starts with 'A'
SELECT * FROM employees WHERE age IN (25, 35); -- Matches rows where age is either 25 or 35
SELECT * FROM employees WHERE NOT (name = 'Bob' AND age = 30); -- Matches rows where name is not 'Bob' OR age is not 30

```

## 15. Compound "Where" Clauses

We can also use multiple conditions in a  `WHERE`  clause to create more  complex filters. We can use the  `AND`  and  `OR`  operators to combine conditions in a single  `WHERE`  clause.

Here is an example of using  `AND`  to filter rows from an  `employees`  table based on both name and age:

```
SELECT * FROM employees WHERE name = 'Alice' AND age > 25;

```

This will retrieve all columns (`*`) from the  `employees`  table where the  `name`  column is  `'Alice'`  and the  `age`  column is greater than 25.

Here is an example of using  `OR`  to filter rows based on two different conditions:

```
SELECT * FROM employees WHERE name = 'Alice' OR age > 30;

```

This will retrieve all columns (`*`) from the  `employees`  table where the  `name`  column is  `'Alice'`  or the  `age`  column is greater than 30.

## 16. A "Where" Exercise Overview

Let's practice using the  `WHERE`  keyword to filter rows from a table.

Suppose we have an  `orders`  table that contains information about customer orders, including the customer's name, the date the order was placed, and the total amount of the order. We want to retrieve all orders placed by customers named 'Alice' that were placed on or after January 1st, 2020.

## Coding Exercise 3: Practicing Where Statements

Write a  SQL query  that retrieves all columns from the  `orders`  table where the  `customer_name`  column is 'Alice' and the  `order_date`  column is greater than or equal to '2020-01-01'.

## 17. A "Where" Solution

Here is a possible solution to  Coding Exercise 3:

```
SELECT * FROM orders
WHERE customer_name = 'Alice'
AND order_date >= '2020-01-01';

```

This solution uses  `WHERE`  to filter rows from the  `orders`  table based on two conditions: that the  `customer_name`  column is  `'Alice'`  and that the  `order_date`  column is greater than or equal to  `'2020-01-01'`.

## 18. "Where" With Lists

We can also use the  `IN`  operator in a  `WHERE`  clause to filter rows based on a list of values. Here is an example of using  `IN`  to retrieve rows from a  `users`  table where the  `name`  column is either 'Alice' or 'Bob':
```
SELECT * FROM users WHERE name IN ('Alice', 'Bob');

```

## 19. A "Where" With Lists Solution

Let's practice using the  `IN`  operator in a  `WHERE`  clause.

Suppose we have a  `sales`  table that contains information about phone sales, including the  phone model  and the price per phone. We want to retrieve all rows from the  `sales`  table where the phone model is either 'iPhone' or 'Samsung'.

## Coding Exercise 4: A More Challenging 'Where'

Write a SQL query that retrieves all columnsfrom the  `sales`  table where the  `phone_model`  column is either 'iPhone' or 'Samsung'.

## 20. Calculations in "Where" Clauses

We can also perform calculations in a  `WHERE`  clause to filter rows based on the result of a calculation. For example, we can retrieve all rows from a  `sales`  table where the  `price_per_phone`  column is greater than $500:

```
SELECT * FROM sales WHERE price_per_phone > 500;

```

## 21. Solving Calculations

Let's practice using calculations in a  `WHERE`  clause.

Suppose we have a  `products`  table that contains information about products, including the  product name  and the price per unit. We want to retrieve all rows from the  `products`  table where the price per unit is less than $10.

## Coding Exercise 5: Trying Calculations in Where Clauses

Write a SQL query that retrieves all columns from the  `products`  table where the  `price_per_unit`  column is less than $10.

## 22. Updating Rows

In addition to retrieving rows from a table, we can also update rows using the  `UPDATE`  statement. The basic syntax for  `UPDATE`  is as follows:

```
UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;

```

Here is an example of using  `UPDATE`  to set the  `price_per_phone`  of all rows in a  `sales`  table where the  `phone_model`  is 'iPhone' to $600:

```
UPDATE sales SET price_per_phone = 600 WHERE phone_model = 'iPhone';

```

## 23. Deleting Rows

We can also delete rows from a table using the  `DELETE`  statement. The basic syntax for  `DELETE`  is as follows:

```
DELETE FROM table_name WHERE condition;

```

Here is an example of using  `DELETE`  to delete all rows from a  `sales`  table where the  `phone_model`  is 'iPhone':

```
DELETE FROM sales WHERE phone_model = 'iPhone';

```

## Coding Exercise 6: Try Updating Records In a Table!

Let's practice using the  `UPDATE`  statement to modify rows in a table.

Suppose we have a  `users`  table that contains information about users, including their name and age. We want to update the age of the user named 'Alice' to 35.

## Coding Exercise 6: Try Updating Records In a Table!

Write a SQL query that updates the  `age`  column of the  `users`  table to 35 for the row where the  `name`  column is 'Alice'.

## 24. A Solution for Updating Rows

Here is a possible solution to  Coding Exercise 6:

```
UPDATE users SET age = 35 WHERE name = 'Alice';

```

This solution uses  `UPDATE`  to modify the  `age`  column of the  `users`  table to 35 where the  `name`  column is  `'Alice'`.

## Coding Exercise 7: Practice Deleting Records

Let's practice using the  `DELETE`  statement to delete rows from a table.

Suppose we have a  `customers`  table that contains information about customers, including their name and email address. We want to delete all rows from the  `customers`  table where the  email address  ends in '@example.com'.

## Coding Exercise 7: Practice Deleting Records

Write a SQL query that deletes all rows from the  `customers`  table where the  `email`  column ends in '@example.com'.

## 25. Solution for Deleting Rows

Here is a possible solution to  Coding Exercise 7:

```
DELETE FROM customers WHERE email LIKE '%@example.com';

```

This solution uses  `DELETE`  to remove all rows from the  `customers`  table where the  `email`  column ends in '@example.com'. The  `LIKE`  keyword is used with the  `%`  wildcard to match any email address that ends with '@example.com'.

# One-to-Many Relationship

A one-to-many relationship exists between two tables when one record in the first table corresponds to one or more records in the second table.

## Example

| Students | Classes |
|---|---|
| ID | ID |
| Name | Class Name |
| Age | Teacher |
| Class ID | &#8594; |

In this example, the `Class ID` column in the `Students` table is a foreign key that references the `ID` column in the `Classes` table. This relationship allows us to retrieve all the classes attended by a particular student or all the students attending a particular class.

# Many-to-One Relationship

A many-to-one relationship exists between two tables when many records in the first table correspond to one record in the second table.

## Example

| Orders | Customers |
|---|---|
| ID | ID |
| Date | Name |
| Amount | Email |
| CustID | &#8594; |

In this example, the `CustID` column in the `Orders` table is a foreign key that references the `ID` column in the `Customers` table. This relationship allows us to retrieve all the orders placed by a particular customer.

# Conclusion

Understanding one-to-many and many-to-one relationships is essential for designing efficient and scalable databases. By using foreign keys, we can establish these relationships and retrieve data from multiple tables easily.

# Quiz

In a one-to-many relationship, how many records in the second table correspond to one record in the first table?

* One
* Many
* Zero
* None of the above

**Answer: b**

In a many-to-one relationship, how many records in the first table correspond to one record in the second table?

* One
* Many
* Zero
* None of the above

**Answer: b**

Which of the following is a foreign key in the following table relationship?

| Orders | Customers |
|---|---|
| ID | ID |
| Date | Name |
| Amount | Email |
| CustID | &#8594; |

* ID in the Orders table
* ID in the Customers table
* Name in the Customers table
* CustID in the Orders table

**Answer: d**

## Auto-Generated IDs

When creating a new row in a table, it's common to assign a unique ID to that row. This ID can be used as a primary key or a  foreign key  in other tables. The easiest way to create an auto-generated ID is to use an  integer data type  and set it as the primary key column. Most databases have a built-in function that generates a new ID each time a row is added to the table.

### Example:

Let's say we have a "Customers" table and we want to add an auto-generated ID column:

```
CREATE TABLE Customers (
  ID SERIAL PRIMARY KEY,
  Name TEXT,
  Email TEXT
);

```

In this example, the "ID" column is assigned as the primary key and set to auto-generate a new ID each time a row is added to the table.

## Setting Constraints Around Insertion

When creating a  foreign key column, it's important to set constraints around insertion to ensure that only valid data is added to the table. For example, if we have a "Customers" table and a "Orders" table, we need to ensure that only valid customer IDs are added to the "Orders" table. We can set a  foreign key constraint  to achieve this.

### Example:

Let's say we have an "Orders" table that references the "Customers" table using the "CustID" column:

```
CREATE TABLE Orders (
  ID SERIAL PRIMARY KEY,
  Date DATE,
  Amount NUMERIC(10, 2),
  CustID INTEGER REFERENCES Customers(ID)
);

```

In this example, the "CustID" column in the "Orders" table is a foreign key that references the "ID" column in the "Customers" table. We can set a foreign key constraint to ensure that only valid customer IDs are added to the "Orders" table. If a  customer ID  that does not exist in the "Customers" table is inserted into the "Orders" table, the database will throw an error and prevent the insertion.

## Setting Constraints Around Deletion

When deleting data from a table, it's important to consider the impact on related tables. For example, if we delete a customer from the "Customers" table, we need to decide what should happen to the related records in the "Orders" table. There are several options for handling this situation, including setting foreign keys to null on delete or preventing the deletion altogether.

### Example:

Let's say we have an "Orders" table that references the "Customers" table using the "CustID" column:

```
CREATE TABLE Orders (
  ID SERIAL PRIMARY KEY,
  Date DATE,
  Amount NUMERIC(10, 2),
  CustID INTEGER REFERENCES Customers(ID) ON DELETE SET NULL
);

```

In this example, if we delete a customer from the "Customers" table, we set the foreign key in the "Orders" table to null. Alternatively, we can set a constraint to prevent the deletion of a customer if they have orders associated with them.

### Cascading

In addition to setting foreign keys to null or preventing deletion, we can also use cascading to automatically delete related records when a record in the parent table is deleted. For example, if we delete a customer from the "Customers" table, we might want to automatically delete all the orders associated with that customer from the "Orders" table.

```
CREATE TABLE Orders (
  ID SERIAL PRIMARY KEY,
  Date DATE,
  Amount NUMERIC(10, 2),
  CustID INTEGER REFERENCES Customers(ID) ON DELETE CASCADE
);

```

In this example, if we delete a customer from the "Customers" table, all orders associated with that customer will be automatically deleted from the "Orders" table.

# Adding Some Data

To demonstrate the use of auto-generated IDs and foreign keys in  database design, let's add some data to our "Customers" and "Orders" tables.

```
INSERT INTO Customers (Name, Email) VALUES ('John Smith', 'jsmith@email.com');
INSERT INTO Customers (Name, Email) VALUES ('Jane Doe', 'jdoe@email.com');

```

These commands will add two customers to the "Customers" table.

```
INSERT INTO Orders (Date, Amount, CustID) VALUES ('2022-01-01', 100.00, 1);
INSERT INTO Orders (Date, Amount, CustID) VALUES ('2022-02-01', 200.00, 1);
INSERT INTO Orders (Date, Amount, CustID) VALUES ('2022-03-01', 300.00, 2);

```

These commands will add three orders to the "Orders" table. The first two orders are associated with the first customer, and the third order is associated with the second customer.

# Queries with Joins and Aggregations

We can use joins to combine data from multiple tables. For example, to retrieve a list of all orders with the  customer name  and email, we can use a join between the "Orders" table and the "Customers" table.

```
SELECT Orders.ID, Orders.Date, Orders.Amount, Customers.Name, Customers.Email
FROM Orders
INNER JOIN Customers ON Orders.CustID = Customers.ID;

```

This command will return a table that includes the  order ID, date, amount, and the corresponding customer name and email.

We can also use aggregate functions to calculate  summary statistics  on our data. For example, to calculate the total amount of orders for each customer, we can use a  GROUP BY clause  and the  SUM function.

```
SELECT Customers.Name, SUM(Orders.Amount) AS TotalAmount
FROM Orders
INNER JOIN Customers ON Orders.CustID = Customers.ID
GROUP BY Customers.Name;

```

This command will return a table that includes the customer name and the total amount of orders for that customer.

# Joining Data from Different Tables

Sometimes, we need to join data from multiple tables that are not directly related. In these cases, we can use  multiple joins  to link the tables together.

For example, let's say we have a "Products" table that includes information about the products sold in our orders. We can join the "Orders" table and the "Customers" table as before, and then join the "Products" table to retrieve information about the products in each order.

```
SELECT Customers.Name, Orders.Date, Products.Name AS ProductName, Orders.Amount
FROM Orders
INNER JOIN Customers ON Orders.CustID = Customers.ID
INNER JOIN OrderDetails ON Orders.ID = OrderDetails.OrderID
INNER JOIN Products ON OrderDetails.ProductID = Products.ID;

```

This command will return a table that includes the customer name,  order date,  product name, and order amount for each order.

# Another Quick Join

We can also use a  LEFT JOIN  to retrieve data from one table even if there is no corresponding data in the other table.

For example, let's say we want to retrieve a list of all customers and their orders, even if they haven't made any orders yet.

```
SELECT Customers.Name, Orders.Date, Orders.Amount
FROM Customers
LEFT JOIN Orders ON Customers.ID = Orders.CustID;

```

This command will return a table that includes the customer name and  order information  for each order, but will also include customers with no orders.

# Exercise Overview

Now that we've covered the basics of joins and aggregations, let's practice with some exercises.

# Practice Joining Data

For this exercise, we have two tables: "Employees" and "Departments". The "Employees" table includes information about the employees in a company, and the "Departments" table includes information about the departments in the company.

We want to retrieve a list of all employees and their corresponding department names. Write a  SQL query  to accomplish this task.

```
SELECT Employees.Name, Departments.Name AS Department
FROM Employees
INNER JOIN Departments ON Employees.DepartmentID = Departments.ID;

```

This command will return a table that includes the  employee name  and their corresponding department name.

# A Joinful Solution

In some cases, there may be multiple ways to write a SQL query that accomplishes the same task. Here's an alternate way to write the previous query using a LEFT JOIN.

```
SELECT Employees.Name, Departments.Name AS Department
FROM Employees
LEFT JOIN Departments ON Employees.DepartmentID = Departments.ID;

```

This command will return the same table as before, but will also include employees with no department information.

# Alternate Forms of Syntax

SQL syntax  can vary between database management systems. Here are some examples of  alternate syntax  for the same commands we've used in this article.

### Auto-Generated IDs (MySQL)

```
CREATE TABLE Customers (
  ID INT AUTO_INCREMENT PRIMARY KEY,
Name VARCHAR(255),
  Email VARCHAR(255)
);

```

In MySQL, we use the AUTO_INCREMENT keyword instead of SERIAL to create an auto-generated ID column.

### Setting Constraints Around Insertion (Oracle)

```
CREATE TABLE Orders (
  ID NUMBER PRIMARY KEY,
  Date DATE,
  Amount NUMBER(10, 2),
  CustID NUMBER,
  CONSTRAINT FK_CustID FOREIGN KEY (CustID) REFERENCES Customers(ID)
);

```

In  Oracle, we use the  CONSTRAINT keyword  to set  foreign key constraints.

### Setting Constraints Around Deletion (SQL Server)

```
CREATE TABLE Orders (
  ID INT PRIMARY KEY,
  Date DATE,
  Amount DECIMAL(10, 2),
  CustID INT FOREIGN KEY REFERENCES Customers(ID) ON DELETE SET NULL
);

```

In SQL Server, we use the ON DELETE SET NULL syntax to set foreign keys to null on delete.

### Joining Data from Different Tables (SQLite)

```
SELECT Customers.Name, Orders.Date, Products.Name AS ProductName, Orders.Amount
FROM Orders
INNER JOIN Customers ON Orders.CustID = Customers.ID
INNER JOIN OrderDetails ON Orders.ID = OrderDetails.OrderID
INNER JOIN Products ON OrderDetails.ProductID = Products.ID;

```

In  SQLite, we use the  INNER JOIN keyword  to join tables together. The syntax for  aggregate functions  and  group by clauses  is the same as in other  database management systems.

### Another Quick Join (PostgreSQL)

```
SELECT Customers.Name, Orders.Date, Orders.Amount
FROM Customers
LEFT JOIN Orders ON Customers.ID = Orders.CustID;

```

In PostgreSQL, we use the  LEFT JOIN keyword  to retrieve data from one table even if there is no corresponding data in the other table.

## Missing Data in Joins

It is possible that some data may be missing or not present in one of the tables being joined. In such cases, there are four types of joins that can be used to handle the  missing data:

1.  **Inner Join**  - returns only the rows that have matching data in both tables.
2.  **Left Join**  - returns all the rows from the left table and the matching rows from the right table. If there is no match, the result will contain null values for the right table.
3.  **Right Join**  - returns all the rows from the right table and the matching rows from the left table. If there is no match, the result will contain null values for the left table.
4.  **Full Outer Join**  - returns all the rows from both tables, including  null values  where there is no match.

## Why Wasn't It Included

Sometimes, a table may not be included in a  join query  because it is not relevant to the analysis or its data may not be needed. In such cases, the table can be omitted from the query altogether.

## Four Kinds of Joins

There are four types of joins in PostgreSQL:

1.  **Inner Join**  - returns only the rows that have matching data in both tables.
2.  **Left Join**  - returns all the rows from the left table and the matching rows from the right table. If there is no match, the result will contain null values for the right table.
3.  **Right Join**  - returns all the rows from the right table and the matching rows from the left table. If there is no match, the result will contain null values for the left table.
4.  **Full Outer Join**  - returns all the rows from both tables, including null values where there is no match.

## Each Join in Practice

Let's look at an example of each type of join in practice:

### Inner Join

The following query returns only the rows that have matching data in both tables:

```
SELECT *
FROM table1
INNER JOIN table2
ON table1.id = table2.id;

```

### Left Join

The following query returns all the rows from the left table and the matching rows from the right table. If there is no match, the result will contain null values for the right table:

```
SELECT *
FROM table1
LEFT JOIN table2
ON table1.id = table2.id;

```

### Right Join

The following query returns all the rows from the  right table  and the matching rows from the left table. If there is no match, the result will contain null values for the left table:

```
SELECT *
FROM table1
RIGHT JOIN table2
ON table1.id = table2.id;

```

### Full Outer Join

The following query returns all the rows from both tables, including null values where there is no match:

```
SELECT *
FROM table1
FULL OUTER JOIN table2
ON table1.id = table2.id;

```

## Does Order Matter?

The order of tables in a join query does not matter. For example, the following queries return the same result:

```
SELECT *
FROM table1
INNER JOIN table2
ON table1.id = table2.id;

SELECT *
FROM table2
INNER JOIN table1
ON table1.id = table2.id;

```

## Quiz 7: Test Your Joining Knowledge

Test your knowledge of joins in PostgreSQL with this quiz.

## Exercise Overview

In this exercise, we will practice using joins on a sample database. We will be using three tables:  `employees`,  `departments`, and  `dept_emp`.

## Coding Exercise 10: Joins, Joins, Join!

Complete the following tasks using joins:

1.  Retrieve the first name,  last name, and  department name  for all employees.
2.  Retrieve the first name, last name, and department name for all employees who worked in the sales department.
3.  Retrieve the first name, last name, and department name for all employees who worked in the sales department between 1990 and 1995.

## Two Possible Solutions

Here are two possible solutions to this exercise:

### Solution 1

```
-- Task 1
SELECT e.first_name, e.last_name, d.dept_name
FROM employees e
INNER JOIN dept_emp de ON e.emp_no = de.emp_no
INNER JOIN departments d ON de.dept_no = d.dept_no;

-- Task 2
SELECT e.first_name, e.last_name, d.dept_name
FROM employees e
INNER JOIN dept_emp de ON e.emp_no = de.emp_no
INNER JOIN departments d ON de.dept_no = d.dept_no
WHERE d.dept_name = 'Sales';

-- Task 3
SELECT e.first_name, e.last_name, d.dept_name
FROM employees e
INNER JOIN dept_emp de ON e.emp_no = de.emp_no
INNER JOIN departments d ON de.dept_no = d.dept_no
WHERE d.dept_name = 'Sales'
AND de.from_date >= '1990-01-01'
AND de.to_date <= '1995-12-31';

```

### Solution 2

```
-- Task 1
SELECT employees.first_name, employees.last_name, departments.dept_name
FROM employees, dept_emp, departments
WHERE employees.emp_no = dept_emp.emp_no
AND dept_emp.dept_no = departments.dept_no;

-- Task 2
SELECT employees.first_name, employees.last_name, departments.dept_name
FROM employees, dept_emp, departments
WHERE employees.emp_no = dept_emp.emp_no
AND dept_emp.dept_no = departments.dept_no
AND departments.dept_name = 'Sales';

-- Task 3
SELECT employees.first_name, employees.last_name, departments.dept_name
FROM employees, dept_emp, departments
WHERE employees.emp_no = dept_emp.emp_no
AND dept_emp.dept_no = departments.dept_no
AND departments.dept_name = 'Sales'
AND dept_emp.from_date >= '1990-01-01'
AND dept_emp.to_date <= '1995-12-31';

```

## Where with Join

In PostgreSQL, it is possible to use  `WHERE`  clauses with joins to filter the results further. For example:

```
SELECT *
FROM table1
INNER JOIN table2
ON table1.id = table2.id
WHERE table1.column = 'value';

```

This query will return only the rows from table1 that have a column value of 'value', and their matching rows from table2.

## Three Way  Joins

It is also possible to join three or more tables in PostgreSQL. For example:

```
SELECT *
FROM table1
INNER JOIN table2
ON table1.id = table2.id
INNER JOIN table3
ON table2.id = table3.id;

```

This query joins three tables, with table1 and table2 joined on their id columns, and then table2 and table3 joined on their id columns.

## A Bit of Practice

Let's look at another example of using joins in practice:

### Problem

We have three tables:  `employees`,  `titles`, and  `salaries`. We want to retrieve the first name, last name, title, and salary for all employees.

### Solution

```
SELECT e.first_name, e.last_name, t.title, s.salary
FROM employees e
INNER JOIN titles t ON e.emp_no = t.emp_no
INNER JOIN salaries s ON e.emp_no = s.emp_no;

```

## Coding Exercise 11: Three Way Exercise

Complete the following task using a three-way join:

1.  Retrieve the  first name, last name, department name, and salary for all employees who worked in the sales department.

## Exercise Solution

```
SELECT e.first_name, e.last_name, d.dept_name, s.salary
FROM employees e
INNER JOIN dept_emp de ON e.emp_no = de.emp_no
INNER JOIN departments d ON de.dept_no = d.dept_no
INNER JOIN salaries s ON e.emp_no = s.emp_no
WHERE d.dept_name = 'Sales';

```

This query retrieves the first name, last name, department name, and salary for all employees who worked in the sales department. We join the  `employees`  and  `dept_emp`  tables on their  `emp_no`  columns, then the  `dept_emp`  and  `departments`  tables on their  `dept_no`  columns, and finally join the  `employees`  and  `salaries`  tables on their  `emp_no`  columns. We use a  `WHERE`  clause to filter the results to only include employees who worked in the sales department.

# Aggregating and Grouping in SQL

In SQL, we can use  aggregate functions  and  grouping  to summarize and analyze data. Aggregate functions perform computations on a set of values and return a single value. Grouping allows us to group data by one or more columns and apply aggregate functions to each group.

## Reference Table

Let's start with an example table that we can use to demonstrate how to use aggregate functions and grouping in SQL. Consider the following table of sales data:

```
sales
+----+------------------+--------+
| id | product_category | revenue|
+----+------------------+--------+
|  1 | Electronics      |   5000 |
|  2 | Clothing         |   2000 |
|  3 | Electronics      |   3000 |
|  4 | Clothing         |   1500 |
|  5 | Furniture        |   4000 |
|  6 | Furniture        |   2500 |
+----+------------------+--------+

```

## Aggregating Data

There are several aggregate functions in SQL which can be used to summarize data. Let's take a look at some examples:

-   `COUNT`: returns the number of rows in a group or table.
-   `SUM`: returns the sum of the values in a group or table.
-   `AVG`: returns the average of the values in a group or table.
-   `MIN`: returns the minimum value in a group or table.
-   `MAX`: returns the  maximum value  in a group or table.

We can use these functions to summarize data and answer questions such as:

-   How many rows are in a table?
-   What is the total revenue for each product category?
-   What is the average revenue across all sales?

Let's run some SQL queries using the  `sales`  table to demonstrate these functions:

```
SELECT COUNT(*) FROM sales;

```

This query returns the number of rows in the  `sales`  table, which is 6.

```
SELECT SUM(revenue) FROM sales;

```

This query returns the sum of the  `revenue`  column in the  `sales`  table, which is 18000.

```
SELECT AVG(revenue) FROM sales;

```

This query returns the average of the  `revenue`  column in the  `sales`  table, which is 3000.

```
SELECT MIN(revenue) FROM sales;

```

This query returns the minimum value in the  `revenue`  column in the  `sales`  table, which is 1500.

```
SELECT MAX(revenue) FROM sales;

```

This query returns the maximum value in the  `revenue`  column in the  `sales`  table, which is 5000.

## Grouping Data

Grouping allows us to group rows in a table by one or more columns and apply aggregate functions to each group. For example, we can group sales data by  product category  and compute the total revenue for each category.

To group data in SQL, we use the  `GROUP BY`  clause. The  `GROUP BY`  clause specifies one or more columns to group the data by. For example:

```
SELECT product_category, SUM(revenue)
FROM sales
GROUP BY product_category;

```

This query groups the  `sales`  table by  `product_category`  and computes the sum of  `revenue`  for each category. The result would be:

```
+------------------+--------+
| product_category | sum    |
+------------------+--------+
| Electronics      |   8000 |
| Clothing         |   3500 |
| Furniture        |   6500 |
+------------------+--------+

```

We can also use the  `HAVING`  clause to filter groups based on their aggregate values. For example, to find product categories with total revenue greater than $5000, we can use the following query:

```
SELECT product_category, SUM(revenue)
FROM sales
GROUP BY product_category
HAVING SUM(revenue) > 5000;

```

This query groups the  `sales`  table by  `product_category`, computes the sum of  `revenue`  for each category, and filters the groups to include only those with total revenue greater than $5000. The result would be:

```
+------------------+--------+
| product_category | sum    |
+------------------+--------+
| Electronics      |   8000 |
| Furniture        |   6500 |
+------------------+--------+

```

## Conclusion

Aggregate functions and grouping are powerful tools for summarizing and analyzing data in SQL. By using these functions, we can quickly answer questions about our data and gain insights into trends and patterns.

# The Basics  of Sorting

In SQL, you can use the  `ORDER BY`  clause to sort the results of your query based on one or more columns. By default, the results are sorted in ascending order, but you can also specify descending order.

Here's the basic syntax for the  `ORDER BY`  clause:

```
SELECT column1, column2, ...
FROM table_name
ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ... ;

```

In this syntax,  `column1`,  `column2`, etc. are the columns that you want to sort by, and  `[ASC|DESC]`  specifies the sort order.

Let's look at an example:

Suppose we have a table called  `employees`  with columns for  `name`,  `age`, and  `salary`. We want to sort the employees by salary in  descending order:

```
SELECT name, age, salary
FROM employees
ORDER BY salary DESC;

```

This will give us a result set that is sorted by salary in descending order.

# Two Variations on Sorting

There are two other variations on the  `ORDER BY`  clause that are worth mentioning: sorting by a calculated column and sorting by a column alias.

## Sorting by a  Calculated Column

In SQL, you can use expressions in the  `ORDER BY`  clause to sort by a calculated column. For example, suppose we want to sort the employees by their salary divided by their age:

```
SELECT name, age, salary, salary/age AS salary_per_age
FROM employees
ORDER BY salary_per_age DESC;

```

This will give us a result set that is sorted by the calculated column  `salary_per_age`.

## Sorting by a Column Alias

You can also sort by a  column alias  that you have defined in the  `SELECT`  clause. For example, suppose we want to sort the employees by their salary divided by their age, and we want to give the column alias  `salary_per_age`:

```
SELECT name, age, salary, salary/age AS salary_per_age
FROM employees
ORDER BY salary_per_age DESC;

```

This will give us a  result set  that is sorted by the column alias  `salary_per_age`.

# Offset and Limit

In SQL, you can use the  `OFFSET`  and  `LIMIT`  clauses to page through the results of your query.  `OFFSET`  specifies the number of rows to skip before starting to return rows, and  `LIMIT`  specifies the maximum number of rows to return.

Here's the basic syntax for  `OFFSET`  and  `LIMIT`:

```
SELECT column1, column2, ...
FROM table_name
ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ... 
OFFSET offset_value
LIMIT limit_value;

```

In this syntax,  `offset_value`  specifies the number of rows to skip, and  `limit_value`  specifies the maximum number of rows to return.

Let's look at an example:

Suppose we have a table called  `employees`  with columns for  `name`,  `age`, and  `salary`. We want to sort the employees by salary in descending order, and we only want to return the top 10 employees:

```
SELECT name, age, salary
FROM employees
ORDER BY salary DESC
LIMIT 10;

```

This will give us a result set that is sorted by salary in descending order, and it only includes the top 10 employees.

# Sorting, Offsetting, and Limiting

Let's practice using the  `ORDER BY`,  `OFFSET`, and  `LIMIT`  clauses together with an example.

Suppose we have a table called  `sales`  with columns for  `date`,  `product`, and  `sales_amount`. We want to find the top 5 sales for the month of January, sorted by sales amount in descending order.

Here's the  SQL query  to do this:

```
SELECT date, product, sales_amount
FROM sales
WHERE date >= '2022-01-01' AND date < '2022-02-01'
ORDER BY sales_amount DESC
OFFSET 0
LIMIT 5;

```

This query will return the top 5 sales for the month of January, sorted by sales amount in descending order.

# Exercise Solution

Here's the solution to the exercise:

```
SELECT name, age, salary
FROM employees
ORDER BY salary DESC
OFFSET 10
LIMIT 5;

```

This query will return the 11th to 15th highest paid employees, sorted by salary in descending order.
